# AllSports í”„ë¡œì íŠ¸ ì „ì²´ íŒŒì¼

ì•„ë˜ íŒŒì¼ë“¤ì„ ìˆœì„œëŒ€ë¡œ ìƒì„±í•˜ì„¸ìš”.

## ğŸ“ í”„ë¡œì íŠ¸ ìƒì„± ë° ì„¤ì •

```bash
# 1. Next.js í”„ë¡œì íŠ¸ ìƒì„±
npx create-next-app@latest allsports --typescript --tailwind --app --no-git

# 2. í”„ë¡œì íŠ¸ ë””ë ‰í† ë¦¬ë¡œ ì´ë™
cd allsports

# 3. í•„ìš”í•œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
npm install prisma @prisma/client bcryptjs jsonwebtoken
npm install -D @types/bcryptjs @types/jsonwebtoken
```

---

## ğŸ“„ package.json

```json
{
  "name": "allsports",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:seed": "prisma db seed",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.7.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "next": "14.0.4",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.0.4",
    "postcss": "^8",
    "prisma": "^5.7.0",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  }
}
```

---

## ğŸ“„ .env.local

```env
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/allsports"

# JWT
JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"

# Next Auth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-nextauth-secret-key-change-this"
```

---

## ğŸ“„ prisma/schema.prisma

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String   @map("password_hash")
  username      String
  isAdmin       Boolean  @default(false) @map("is_admin")
  currentSport  String   @default("ì¶•êµ¬") @map("current_sport")
  city          String   @default("ì„œìš¸")
  district      String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  ownedTeams    Team[]       @relation("TeamOwner")
  teamMembers   TeamMember[]
  createdMatches Match[]     @relation("MatchCreator")
  disputes      Dispute[]
  
  @@map("users")
}

model Team {
  id        String   @id @default(uuid())
  name      String
  sport     String
  city      String
  district  String
  ownerId   String   @map("owner_id")
  points    Int      @default(0)
  wins      Int      @default(0)
  draws     Int      @default(0)
  losses    Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")
  
  owner       User         @relation("TeamOwner", fields: [ownerId], references: [id])
  members     TeamMember[]
  homeMatches Match[]      @relation("HomeTeam")
  awayMatches Match[]      @relation("AwayTeam")
  
  @@unique([name, sport, city, district])
  @@map("teams")
}

model TeamMember {
  id       String   @id @default(uuid())
  teamId   String   @map("team_id")
  userId   String   @map("user_id")
  joinedAt DateTime @default(now()) @map("joined_at")
  
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@map("team_members")
}

model Match {
  id             String    @id @default(uuid())
  sport          String
  homeTeamId     String    @map("home_team_id")
  awayTeamId     String    @map("away_team_id")
  matchDate      DateTime  @map("match_date")
  matchTime      String?   @map("match_time")
  location       String?
  status         String    @default("proposed")
  homeScore      Int?      @map("home_score")
  awayScore      Int?      @map("away_score")
  createdBy      String    @map("created_by")
  resultEnteredAt DateTime? @map("result_entered_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  
  homeTeam  Team     @relation("HomeTeam", fields: [homeTeamId], references: [id])
  awayTeam  Team     @relation("AwayTeam", fields: [awayTeamId], references: [id])
  creator   User     @relation("MatchCreator", fields: [createdBy], references: [id])
  disputes  Dispute[]
  
  @@map("matches")
}

model Dispute {
  id         String    @id @default(uuid())
  matchId    String    @map("match_id")
  reportedBy String    @map("reported_by")
  reason     String
  status     String    @default("open")
  adminNotes String?   @map("admin_notes")
  resolvedAt DateTime? @map("resolved_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  
  match    Match @relation(fields: [matchId], references: [id])
  reporter User  @relation(fields: [reportedBy], references: [id])
  
  @@map("disputes")
}

model Region {
  id       Int     @id @default(autoincrement())
  city     String
  district String
  isActive Boolean @default(true) @map("is_active")
  
  @@unique([city, district])
  @@map("regions")
}
```

---

## ğŸ“„ prisma/seed.ts

```typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  // ì§€ì—­ ë°ì´í„° ì¶”ê°€
  const regions = [
    // ì„œìš¸
    { city: 'ì„œìš¸', district: 'ê°•ë‚¨êµ¬' },
    { city: 'ì„œìš¸', district: 'ê°•ë™êµ¬' },
    { city: 'ì„œìš¸', district: 'ê°•ì„œêµ¬' },
    { city: 'ì„œìš¸', district: 'ê´€ì•…êµ¬' },
    { city: 'ì„œìš¸', district: 'ì†¡íŒŒêµ¬' },
    { city: 'ì„œìš¸', district: 'ì„œì´ˆêµ¬' },
    { city: 'ì„œìš¸', district: 'ë§ˆí¬êµ¬' },
    { city: 'ì„œìš¸', district: 'ìš©ì‚°êµ¬' },
    // ê²½ê¸°ë„
    { city: 'ê²½ê¸°ë„', district: 'ìˆ˜ì›ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ì„±ë‚¨ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ê³ ì–‘ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ìš©ì¸ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ë¶€ì²œì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ì•ˆì–‘ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'ì•ˆì‚°ì‹œ' },
    { city: 'ê²½ê¸°ë„', district: 'í™”ì„±ì‹œ' }
  ];
  
  for (const region of regions) {
    await prisma.region.upsert({
      where: {
        city_district: {
          city: region.city,
          district: region.district
        }
      },
      update: {},
      create: region
    });
  }
  
  // ê´€ë¦¬ì ê³„ì • ìƒì„±
  const hashedPassword = await bcrypt.hash('admin123', 10);
  await prisma.user.upsert({
    where: { email: 'admin@allsports.com' },
    update: {},
    create: {
      email: 'admin@allsports.com',
      passwordHash: hashedPassword,
      username: 'ê´€ë¦¬ì',
      isAdmin: true,
      city: 'ì„œìš¸',
      district: 'ê°•ë‚¨êµ¬'
    }
  });
  
  console.log('âœ… Seed data created successfully');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

## ğŸ“„ lib/prisma.ts

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

---

## ğŸ“„ lib/auth.ts

```typescript
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { prisma } from '@/lib/prisma';

const JWT_SECRET = process.env.JWT_SECRET!;

export interface TokenPayload {
  userId: string;
  email: string;
  isAdmin: boolean;
}

export function generateToken(payload: TokenPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
}

export function verifyToken(token: string): TokenPayload {
  return jwt.verify(token, JWT_SECRET) as TokenPayload;
}

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

export async function comparePassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

export async function getUserFromToken(token: string | undefined) {
  if (!token) return null;
  
  try {
    const payload = verifyToken(token);
    const user = await prisma.user.findUnique({
      where: { id: payload.userId }
    });
    return user;
  } catch (error) {
    return null;
  }
}
```

---

## ğŸ“„ app/api/auth/register/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hashPassword, generateToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const { email, password, username, city, district, sport } = await request.json();
    
    // ì´ë©”ì¼ ì¤‘ë³µ ì²´í¬
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });
    
    if (existingUser) {
      return NextResponse.json(
        { error: 'ì´ë¯¸ ì‚¬ìš©ì¤‘ì¸ ì´ë©”ì¼ì…ë‹ˆë‹¤' },
        { status: 400 }
      );
    }
    
    // ì‚¬ìš©ì ìƒì„±
    const hashedPassword = await hashPassword(password);
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash: hashedPassword,
        username,
        city,
        district,
        currentSport: sport || 'ì¶•êµ¬'
      }
    });
    
    // JWT í† í° ìƒì„±
    const token = generateToken({
      userId: user.id,
      email: user.email,
      isAdmin: user.isAdmin
    });
    
    return NextResponse.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        isAdmin: user.isAdmin,
        currentSport: user.currentSport
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json(
      { error: 'íšŒì›ê°€ì… ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/api/auth/login/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { comparePassword, generateToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const { email, password } = await request.json();
    
    // ì‚¬ìš©ì ì¡°íšŒ
    const user = await prisma.user.findUnique({
      where: { email }
    });
    
    if (!user) {
      return NextResponse.json(
        { error: 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' },
        { status: 401 }
      );
    }
    
    // ë¹„ë°€ë²ˆí˜¸ ê²€ì¦
    const isValid = await comparePassword(password, user.passwordHash);
    
    if (!isValid) {
      return NextResponse.json(
        { error: 'ì´ë©”ì¼ ë˜ëŠ” ë¹„ë°€ë²ˆí˜¸ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤' },
        { status: 401 }
      );
    }
    
    // JWT í† í° ìƒì„±
    const token = generateToken({
      userId: user.id,
      email: user.email,
      isAdmin: user.isAdmin
    });
    
    return NextResponse.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        isAdmin: user.isAdmin,
        currentSport: user.currentSport,
        city: user.city,
        district: user.district
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      { error: 'ë¡œê·¸ì¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/api/teams/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

// íŒ€ ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport');
    const city = searchParams.get('city');
    const district = searchParams.get('district');
    
    const where: any = {};
    if (sport) where.sport = sport;
    if (city) where.city = city;
    if (district) where.district = district;
    
    const teams = await prisma.team.findMany({
      where,
      include: {
        owner: {
          select: {
            id: true,
            username: true
          }
        },
        _count: {
          select: {
            members: true
          }
        }
      },
      orderBy: {
        points: 'desc'
      }
    });
    
    return NextResponse.json(teams);
  } catch (error) {
    console.error('Get teams error:', error);
    return NextResponse.json(
      { error: 'íŒ€ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}

// íŒ€ ìƒì„±
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' },
        { status: 401 }
      );
    }
    
    const { name, sport, city, district } = await request.json();
    
    // ì¤‘ë³µ ì²´í¬
    const existingTeam = await prisma.team.findFirst({
      where: {
        name,
        sport,
        city,
        district
      }
    });
    
    if (existingTeam) {
      return NextResponse.json(
        { error: 'í•´ë‹¹ ì§€ì—­ì— ì´ë¯¸ ê°™ì€ ì´ë¦„ì˜ íŒ€ì´ ì¡´ì¬í•©ë‹ˆë‹¤' },
        { status: 400 }
      );
    }
    
    // íŠ¸ëœì­ì…˜ìœ¼ë¡œ íŒ€ ìƒì„± + ë©¤ë²„ ì¶”ê°€
    const team = await prisma.$transaction(async (tx) => {
      // íŒ€ ìƒì„±
      const newTeam = await tx.team.create({
        data: {
          name,
          sport,
          city,
          district,
          ownerId: user.id
        }
      });
      
      // ì˜¤ë„ˆë¥¼ ë©¤ë²„ë¡œ ì¶”ê°€
      await tx.teamMember.create({
        data: {
          teamId: newTeam.id,
          userId: user.id
        }
      });
      
      return newTeam;
    });
    
    return NextResponse.json(team);
  } catch (error) {
    console.error('Create team error:', error);
    return NextResponse.json(
      { error: 'íŒ€ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/api/matches/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

// ì‹œí•© ëª©ë¡ ì¡°íšŒ
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport');
    const status = searchParams.get('status');
    
    const where: any = {};
    if (sport) where.sport = sport;
    if (status) where.status = status;
    
    const matches = await prisma.match.findMany({
      where,
      include: {
        homeTeam: true,
        awayTeam: true,
        creator: {
          select: {
            id: true,
            username: true
          }
        }
      },
      orderBy: {
        matchDate: 'desc'
      }
    });
    
    return NextResponse.json(matches);
  } catch (error) {
    console.error('Get matches error:', error);
    return NextResponse.json(
      { error: 'ì‹œí•© ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}

// ì‹œí•© ìƒì„±/ì œì•ˆ
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' },
        { status: 401 }
      );
    }
    
    const { homeTeamId, awayTeamId, matchDate, matchTime, location } = await request.json();
    
    // í™ˆíŒ€ ì˜¤ë„ˆ í™•ì¸
    const homeTeam = await prisma.team.findUnique({
      where: { id: homeTeamId }
    });
    
    if (homeTeam?.ownerId !== user.id) {
      return NextResponse.json(
        { error: 'íŒ€ ì˜¤ë„ˆë§Œ ì‹œí•©ì„ ìƒì„±í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤' },
        { status: 403 }
      );
    }
    
    const match = await prisma.match.create({
      data: {
        sport: homeTeam.sport,
        homeTeamId,
        awayTeamId,
        matchDate: new Date(matchDate),
        matchTime,
        location,
        status: 'proposed',
        createdBy: user.id
      },
      include: {
        homeTeam: true,
        awayTeam: true
      }
    });
    
    return NextResponse.json(match);
  } catch (error) {
    console.error('Create match error:', error);
    return NextResponse.json(
      { error: 'ì‹œí•© ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/api/matches/[id]/result/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: 'ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤' },
        { status: 401 }
      );
    }
    
    const { homeScore, awayScore } = await request.json();
    
    // ë§¤ì¹˜ ì¡°íšŒ
    const match = await prisma.match.findUnique({
      where: { id: params.id },
      include: { homeTeam: true }
    });
    
    if (!match) {
      return NextResponse.json(
        { error: 'ì‹œí•©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤' },
        { status: 404 }
      );
    }
    
    // í™ˆíŒ€ ì˜¤ë„ˆ í™•ì¸
    if (match.homeTeam.ownerId !== user.id && !user.isAdmin) {
      return NextResponse.json(
        { error: 'í™ˆíŒ€ ì˜¤ë„ˆë§Œ ê²°ê³¼ë¥¼ ì…ë ¥í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤' },
        { status: 403 }
      );
    }
    
    // íŠ¸ëœì­ì…˜ìœ¼ë¡œ ê²°ê³¼ ì—…ë°ì´íŠ¸
    await prisma.$transaction(async (tx) => {
      // ë§¤ì¹˜ ê²°ê³¼ ì €ì¥
      await tx.match.update({
        where: { id: params.id },
        data: {
          homeScore,
          awayScore,
          status: 'completed',
          resultEnteredAt: new Date()
        }
      });
      
      // íŒ€ í†µê³„ ì—…ë°ì´íŠ¸
      if (homeScore > awayScore) {
        // í™ˆíŒ€ ìŠ¹ë¦¬
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: {
            wins: { increment: 1 },
            points: { increment: 3 }
          }
        });
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: { losses: { increment: 1 } }
        });
      } else if (homeScore < awayScore) {
        // ì›ì •íŒ€ ìŠ¹ë¦¬
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: {
            wins: { increment: 1 },
            points: { increment: 3 }
          }
        });
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: { losses: { increment: 1 } }
        });
      } else {
        // ë¬´ìŠ¹ë¶€
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: {
            draws: { increment: 1 },
            points: { increment: 1 }
          }
        });
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: {
            draws: { increment: 1 },
            points: { increment: 1 }
          }
        });
      }
    });
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Update result error:', error);
    return NextResponse.json(
      { error: 'ê²°ê³¼ ì…ë ¥ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/api/rankings/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport') || 'ì¶•êµ¬';
    const scope = searchParams.get('scope') || 'national';
    const city = searchParams.get('city');
    const district = searchParams.get('district');
    
    let where: any = { sport };
    
    switch(scope) {
      case 'district':
        if (city && district) {
          where.city = city;
          where.district = district;
        }
        break;
      case 'city':
        if (city) {
          where.city = city;
        }
        break;
      case 'national':
      default:
        // sportë§Œ í•„í„°ë§
        break;
    }
    
    const rankings = await prisma.team.findMany({
      where,
      orderBy: [
        { points: 'desc' },
        { wins: 'desc' },
        { draws: 'desc' }
      ],
      include: {
        _count: {
          select: { members: true }
        }
      }
    });
    
    // ìˆœìœ„ ì¶”ê°€
    const rankedTeams = rankings.map((team, index) => ({
      ...team,
      rank: index + 1
    }));
    
    return NextResponse.json(rankedTeams);
  } catch (error) {
    console.error('Get rankings error:', error);
    return NextResponse.json(
      { error: 'ë­í‚¹ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤' },
      { status: 500 }
    );
  }
}
```

---

## ğŸ“„ app/page.tsx

```tsx
'use client';

import { useState, useEffect } from 'react';

export default function HomePage() {
  const [currentSport, setCurrentSport] = useState('ì¶•êµ¬');
  const [user, setUser] = useState<any>(null);
  const [myTeams, setMyTeams] = useState([]);
  const [upcomingMatches, setUpcomingMatches] = useState([]);
  const [rankings, setRankings] = useState([]);

  useEffect(() => {
    // ë¡œì»¬ìŠ¤í† ë¦¬ì§€ì—ì„œ ì‚¬ìš©ì ì •ë³´ ê°€ì ¸ì˜¤ê¸°
    const userData = localStorage.getItem('user');
    if (userData) {
      setUser(JSON.parse(userData));
    }
    
    // ë°ì´í„° ë¡œë“œ
    loadData();
  }, [currentSport]);

  const loadData = async () => {
    // ì—¬ê¸°ì— API í˜¸ì¶œ ë¡œì§ ì¶”ê°€
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* í—¤ë” */}
      <header className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <h1 className="text-2xl font-bold text-gray-900">AllSports</h1>
        </div>
      </header>

      {/* ìŠ¤í¬ì¸  ì „í™˜ í† ê¸€ */}
      <div className="flex justify-center p-4 bg-white border-b">
        <div className="flex gap-2">
          <button 
            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
              currentSport === 'ì¶•êµ¬' 
                ? 'bg-blue-500 text-white' 
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
            onClick={() => setCurrentSport('ì¶•êµ¬')}
          >
            âš½ ì¶•êµ¬
          </button>
          <button 
            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
              currentSport === 'í’‹ì‚´' 
                ? 'bg-blue-500 text-white' 
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
            onClick={() => setCurrentSport('í’‹ì‚´')}
          >
            âš½ í’‹ì‚´
          </button>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {/* ë‚´ íŒ€ ì •ë³´ */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">ë‚´ íŒ€</h2>
            {myTeams.length > 0 ? (
              <div className="space-y-3">
                {/* íŒ€ ì •ë³´ í‘œì‹œ */}
              </div>
            ) : (
              <p className="text-gray-500">ì•„ì§ ê°€ì…í•œ íŒ€ì´ ì—†ìŠµë‹ˆë‹¤</p>
            )}
          </div>

          {/* ì˜ˆì •ëœ ê²½ê¸° */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">ì˜ˆì •ëœ ê²½ê¸°</h2>
            {upcomingMatches.length > 0 ? (
              <div className="space-y-3">
                {/* ê²½ê¸° ì •ë³´ í‘œì‹œ */}
              </div>
            ) : (
              <p className="text-gray-500">ì˜ˆì •ëœ ê²½ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤</p>
            )}
          </div>

          {/* ì§€ì—­ ë­í‚¹ TOP 5 */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">ì§€ì—­ TOP 5</h2>
            {rankings.length > 0 ? (
              <div className="space-y-2">
                {/* ë­í‚¹ í‘œì‹œ */}
              </div>
            ) : (
              <p className="text-gray-500">ë­í‚¹ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤</p>
            )}
          </div>
        </div>

        {/* ë¹ ë¥¸ ë©”ë‰´ */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-8">
          <a href="/teams" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">ğŸ‘¥</div>
            <div className="font-medium">íŒ€ ê´€ë¦¬</div>
          </a>
          <a href="/matches" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">âš½</div>
            <div className="font-medium">ì‹œí•© ê´€ë¦¬</div>
          </a>
          <a href="/rankings" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">ğŸ†</div>
            <div className="font-medium">ë­í‚¹</div>
          </a>
          <a href="/profile" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">ğŸ‘¤</div>
            <div className="font-medium">ë§ˆì´í˜ì´ì§€</div>
          </a>
        </div>
      </div>
    </div>
  );
}
```

---

## ğŸ“„ app/layout.tsx

```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'AllSports - ì•„ë§ˆì¶”ì–´ ìŠ¤í¬ì¸  ë§¤ì¹­ í”Œë«í¼',
  description: 'ì¶•êµ¬ì™€ í’‹ì‚´ íŒ€ ë§¤ì¹­ ë° ë­í‚¹ ì‹œìŠ¤í…œ',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

---

## ğŸ“„ app/globals.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

## ğŸ“„ tailwind.config.ts

```typescript
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
```

---

## ğŸ“„ tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

---

## ğŸš€ ì‹¤í–‰ ë°©ë²•

1. ìœ„ì˜ ëª¨ë“  íŒŒì¼ì„ ìƒì„±í•œ í›„:

```bash
# ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜
npx prisma generate
npx prisma migrate dev --name init

# ì´ˆê¸° ë°ì´í„° ì‹œë”©
npx prisma db seed

# ê°œë°œ ì„œë²„ ì‹¤í–‰
npm run dev
```

2. ë¸Œë¼ìš°ì €ì—ì„œ http://localhost:3000 ì ‘ì†

3. ê´€ë¦¬ì ë¡œê·¸ì¸:
   - ì´ë©”ì¼: admin@allsports.com
   - ë¹„ë°€ë²ˆí˜¸: admin123

---

## ğŸ“ ì¶”ê°€ êµ¬í˜„ í•„ìš” í˜ì´ì§€

- `/login` - ë¡œê·¸ì¸ í˜ì´ì§€
- `/register` - íšŒì›ê°€ì… í˜ì´ì§€
- `/teams` - íŒ€ ëª©ë¡ í˜ì´ì§€
- `/teams/[id]` - íŒ€ ìƒì„¸ í˜ì´ì§€
- `/matches` - ì‹œí•© ê´€ë¦¬ í˜ì´ì§€
- `/rankings` - ë­í‚¹ í˜ì´ì§€
- `/profile` - ë§ˆì´í˜ì´ì§€
- `/admin` - ê´€ë¦¬ì í˜ì´ì§€

ê° í˜ì´ì§€ëŠ” ìœ„ì˜ API ì—”ë“œí¬ì¸íŠ¸ë¥¼ í™œìš©í•˜ì—¬ êµ¬í˜„í•˜ì‹œë©´ ë©ë‹ˆë‹¤.