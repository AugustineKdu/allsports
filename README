# AllSports 프로젝트 전체 파일

아래 파일들을 순서대로 생성하세요.

## 📁 프로젝트 생성 및 설정

```bash
# 1. Next.js 프로젝트 생성
npx create-next-app@latest allsports --typescript --tailwind --app --no-git

# 2. 프로젝트 디렉토리로 이동
cd allsports

# 3. 필요한 패키지 설치
npm install prisma @prisma/client bcryptjs jsonwebtoken
npm install -D @types/bcryptjs @types/jsonwebtoken
```

---

## 📄 package.json

```json
{
  "name": "allsports",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate dev",
    "prisma:seed": "prisma db seed",
    "prisma:studio": "prisma studio"
  },
  "dependencies": {
    "@prisma/client": "^5.7.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "next": "14.0.4",
    "react": "^18",
    "react-dom": "^18"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "autoprefixer": "^10.0.1",
    "eslint": "^8",
    "eslint-config-next": "14.0.4",
    "postcss": "^8",
    "prisma": "^5.7.0",
    "tailwindcss": "^3.3.0",
    "typescript": "^5"
  },
  "prisma": {
    "seed": "ts-node --compiler-options {\"module\":\"CommonJS\"} prisma/seed.ts"
  }
}
```

---

## 📄 .env.local

```env
# Database
DATABASE_URL="postgresql://user:password@localhost:5432/allsports"

# JWT
JWT_SECRET="your-super-secret-jwt-key-change-this-in-production"

# Next Auth
NEXTAUTH_URL="http://localhost:3000"
NEXTAUTH_SECRET="your-nextauth-secret-key-change-this"
```

---

## 📄 prisma/schema.prisma

```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  passwordHash  String   @map("password_hash")
  username      String
  isAdmin       Boolean  @default(false) @map("is_admin")
  currentSport  String   @default("축구") @map("current_sport")
  city          String   @default("서울")
  district      String?
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  
  ownedTeams    Team[]       @relation("TeamOwner")
  teamMembers   TeamMember[]
  createdMatches Match[]     @relation("MatchCreator")
  disputes      Dispute[]
  
  @@map("users")
}

model Team {
  id        String   @id @default(uuid())
  name      String
  sport     String
  city      String
  district  String
  ownerId   String   @map("owner_id")
  points    Int      @default(0)
  wins      Int      @default(0)
  draws     Int      @default(0)
  losses    Int      @default(0)
  createdAt DateTime @default(now()) @map("created_at")
  
  owner       User         @relation("TeamOwner", fields: [ownerId], references: [id])
  members     TeamMember[]
  homeMatches Match[]      @relation("HomeTeam")
  awayMatches Match[]      @relation("AwayTeam")
  
  @@unique([name, sport, city, district])
  @@map("teams")
}

model TeamMember {
  id       String   @id @default(uuid())
  teamId   String   @map("team_id")
  userId   String   @map("user_id")
  joinedAt DateTime @default(now()) @map("joined_at")
  
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  @@unique([teamId, userId])
  @@map("team_members")
}

model Match {
  id             String    @id @default(uuid())
  sport          String
  homeTeamId     String    @map("home_team_id")
  awayTeamId     String    @map("away_team_id")
  matchDate      DateTime  @map("match_date")
  matchTime      String?   @map("match_time")
  location       String?
  status         String    @default("proposed")
  homeScore      Int?      @map("home_score")
  awayScore      Int?      @map("away_score")
  createdBy      String    @map("created_by")
  resultEnteredAt DateTime? @map("result_entered_at")
  createdAt      DateTime  @default(now()) @map("created_at")
  updatedAt      DateTime  @updatedAt @map("updated_at")
  
  homeTeam  Team     @relation("HomeTeam", fields: [homeTeamId], references: [id])
  awayTeam  Team     @relation("AwayTeam", fields: [awayTeamId], references: [id])
  creator   User     @relation("MatchCreator", fields: [createdBy], references: [id])
  disputes  Dispute[]
  
  @@map("matches")
}

model Dispute {
  id         String    @id @default(uuid())
  matchId    String    @map("match_id")
  reportedBy String    @map("reported_by")
  reason     String
  status     String    @default("open")
  adminNotes String?   @map("admin_notes")
  resolvedAt DateTime? @map("resolved_at")
  createdAt  DateTime  @default(now()) @map("created_at")
  
  match    Match @relation(fields: [matchId], references: [id])
  reporter User  @relation(fields: [reportedBy], references: [id])
  
  @@map("disputes")
}

model Region {
  id       Int     @id @default(autoincrement())
  city     String
  district String
  isActive Boolean @default(true) @map("is_active")
  
  @@unique([city, district])
  @@map("regions")
}
```

---

## 📄 prisma/seed.ts

```typescript
import { PrismaClient } from '@prisma/client';
import bcrypt from 'bcryptjs';

const prisma = new PrismaClient();

async function main() {
  // 지역 데이터 추가
  const regions = [
    // 서울
    { city: '서울', district: '강남구' },
    { city: '서울', district: '강동구' },
    { city: '서울', district: '강서구' },
    { city: '서울', district: '관악구' },
    { city: '서울', district: '송파구' },
    { city: '서울', district: '서초구' },
    { city: '서울', district: '마포구' },
    { city: '서울', district: '용산구' },
    // 경기도
    { city: '경기도', district: '수원시' },
    { city: '경기도', district: '성남시' },
    { city: '경기도', district: '고양시' },
    { city: '경기도', district: '용인시' },
    { city: '경기도', district: '부천시' },
    { city: '경기도', district: '안양시' },
    { city: '경기도', district: '안산시' },
    { city: '경기도', district: '화성시' }
  ];
  
  for (const region of regions) {
    await prisma.region.upsert({
      where: {
        city_district: {
          city: region.city,
          district: region.district
        }
      },
      update: {},
      create: region
    });
  }
  
  // 관리자 계정 생성
  const hashedPassword = await bcrypt.hash('admin123', 10);
  await prisma.user.upsert({
    where: { email: 'admin@allsports.com' },
    update: {},
    create: {
      email: 'admin@allsports.com',
      passwordHash: hashedPassword,
      username: '관리자',
      isAdmin: true,
      city: '서울',
      district: '강남구'
    }
  });
  
  console.log('✅ Seed data created successfully');
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });
```

---

## 📄 lib/prisma.ts

```typescript
import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;
```

---

## 📄 lib/auth.ts

```typescript
import jwt from 'jsonwebtoken';
import bcrypt from 'bcryptjs';
import { prisma } from '@/lib/prisma';

const JWT_SECRET = process.env.JWT_SECRET!;

export interface TokenPayload {
  userId: string;
  email: string;
  isAdmin: boolean;
}

export function generateToken(payload: TokenPayload): string {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '7d' });
}

export function verifyToken(token: string): TokenPayload {
  return jwt.verify(token, JWT_SECRET) as TokenPayload;
}

export async function hashPassword(password: string): Promise<string> {
  return bcrypt.hash(password, 10);
}

export async function comparePassword(password: string, hash: string): Promise<boolean> {
  return bcrypt.compare(password, hash);
}

export async function getUserFromToken(token: string | undefined) {
  if (!token) return null;
  
  try {
    const payload = verifyToken(token);
    const user = await prisma.user.findUnique({
      where: { id: payload.userId }
    });
    return user;
  } catch (error) {
    return null;
  }
}
```

---

## 📄 app/api/auth/register/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { hashPassword, generateToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const { email, password, username, city, district, sport } = await request.json();
    
    // 이메일 중복 체크
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });
    
    if (existingUser) {
      return NextResponse.json(
        { error: '이미 사용중인 이메일입니다' },
        { status: 400 }
      );
    }
    
    // 사용자 생성
    const hashedPassword = await hashPassword(password);
    const user = await prisma.user.create({
      data: {
        email,
        passwordHash: hashedPassword,
        username,
        city,
        district,
        currentSport: sport || '축구'
      }
    });
    
    // JWT 토큰 생성
    const token = generateToken({
      userId: user.id,
      email: user.email,
      isAdmin: user.isAdmin
    });
    
    return NextResponse.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        isAdmin: user.isAdmin,
        currentSport: user.currentSport
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json(
      { error: '회원가입 처리 중 오류가 발생했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/api/auth/login/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { comparePassword, generateToken } from '@/lib/auth';

export async function POST(request: NextRequest) {
  try {
    const { email, password } = await request.json();
    
    // 사용자 조회
    const user = await prisma.user.findUnique({
      where: { email }
    });
    
    if (!user) {
      return NextResponse.json(
        { error: '이메일 또는 비밀번호가 올바르지 않습니다' },
        { status: 401 }
      );
    }
    
    // 비밀번호 검증
    const isValid = await comparePassword(password, user.passwordHash);
    
    if (!isValid) {
      return NextResponse.json(
        { error: '이메일 또는 비밀번호가 올바르지 않습니다' },
        { status: 401 }
      );
    }
    
    // JWT 토큰 생성
    const token = generateToken({
      userId: user.id,
      email: user.email,
      isAdmin: user.isAdmin
    });
    
    return NextResponse.json({
      token,
      user: {
        id: user.id,
        email: user.email,
        username: user.username,
        isAdmin: user.isAdmin,
        currentSport: user.currentSport,
        city: user.city,
        district: user.district
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json(
      { error: '로그인 처리 중 오류가 발생했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/api/teams/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

// 팀 목록 조회
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport');
    const city = searchParams.get('city');
    const district = searchParams.get('district');
    
    const where: any = {};
    if (sport) where.sport = sport;
    if (city) where.city = city;
    if (district) where.district = district;
    
    const teams = await prisma.team.findMany({
      where,
      include: {
        owner: {
          select: {
            id: true,
            username: true
          }
        },
        _count: {
          select: {
            members: true
          }
        }
      },
      orderBy: {
        points: 'desc'
      }
    });
    
    return NextResponse.json(teams);
  } catch (error) {
    console.error('Get teams error:', error);
    return NextResponse.json(
      { error: '팀 목록을 불러오는데 실패했습니다' },
      { status: 500 }
    );
  }
}

// 팀 생성
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다' },
        { status: 401 }
      );
    }
    
    const { name, sport, city, district } = await request.json();
    
    // 중복 체크
    const existingTeam = await prisma.team.findFirst({
      where: {
        name,
        sport,
        city,
        district
      }
    });
    
    if (existingTeam) {
      return NextResponse.json(
        { error: '해당 지역에 이미 같은 이름의 팀이 존재합니다' },
        { status: 400 }
      );
    }
    
    // 트랜잭션으로 팀 생성 + 멤버 추가
    const team = await prisma.$transaction(async (tx) => {
      // 팀 생성
      const newTeam = await tx.team.create({
        data: {
          name,
          sport,
          city,
          district,
          ownerId: user.id
        }
      });
      
      // 오너를 멤버로 추가
      await tx.teamMember.create({
        data: {
          teamId: newTeam.id,
          userId: user.id
        }
      });
      
      return newTeam;
    });
    
    return NextResponse.json(team);
  } catch (error) {
    console.error('Create team error:', error);
    return NextResponse.json(
      { error: '팀 생성에 실패했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/api/matches/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

// 시합 목록 조회
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport');
    const status = searchParams.get('status');
    
    const where: any = {};
    if (sport) where.sport = sport;
    if (status) where.status = status;
    
    const matches = await prisma.match.findMany({
      where,
      include: {
        homeTeam: true,
        awayTeam: true,
        creator: {
          select: {
            id: true,
            username: true
          }
        }
      },
      orderBy: {
        matchDate: 'desc'
      }
    });
    
    return NextResponse.json(matches);
  } catch (error) {
    console.error('Get matches error:', error);
    return NextResponse.json(
      { error: '시합 목록을 불러오는데 실패했습니다' },
      { status: 500 }
    );
  }
}

// 시합 생성/제안
export async function POST(request: NextRequest) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다' },
        { status: 401 }
      );
    }
    
    const { homeTeamId, awayTeamId, matchDate, matchTime, location } = await request.json();
    
    // 홈팀 오너 확인
    const homeTeam = await prisma.team.findUnique({
      where: { id: homeTeamId }
    });
    
    if (homeTeam?.ownerId !== user.id) {
      return NextResponse.json(
        { error: '팀 오너만 시합을 생성할 수 있습니다' },
        { status: 403 }
      );
    }
    
    const match = await prisma.match.create({
      data: {
        sport: homeTeam.sport,
        homeTeamId,
        awayTeamId,
        matchDate: new Date(matchDate),
        matchTime,
        location,
        status: 'proposed',
        createdBy: user.id
      },
      include: {
        homeTeam: true,
        awayTeam: true
      }
    });
    
    return NextResponse.json(match);
  } catch (error) {
    console.error('Create match error:', error);
    return NextResponse.json(
      { error: '시합 생성에 실패했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/api/matches/[id]/result/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';
import { getUserFromToken } from '@/lib/auth';

export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    const token = request.headers.get('Authorization')?.replace('Bearer ', '');
    const user = await getUserFromToken(token);
    
    if (!user) {
      return NextResponse.json(
        { error: '로그인이 필요합니다' },
        { status: 401 }
      );
    }
    
    const { homeScore, awayScore } = await request.json();
    
    // 매치 조회
    const match = await prisma.match.findUnique({
      where: { id: params.id },
      include: { homeTeam: true }
    });
    
    if (!match) {
      return NextResponse.json(
        { error: '시합을 찾을 수 없습니다' },
        { status: 404 }
      );
    }
    
    // 홈팀 오너 확인
    if (match.homeTeam.ownerId !== user.id && !user.isAdmin) {
      return NextResponse.json(
        { error: '홈팀 오너만 결과를 입력할 수 있습니다' },
        { status: 403 }
      );
    }
    
    // 트랜잭션으로 결과 업데이트
    await prisma.$transaction(async (tx) => {
      // 매치 결과 저장
      await tx.match.update({
        where: { id: params.id },
        data: {
          homeScore,
          awayScore,
          status: 'completed',
          resultEnteredAt: new Date()
        }
      });
      
      // 팀 통계 업데이트
      if (homeScore > awayScore) {
        // 홈팀 승리
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: {
            wins: { increment: 1 },
            points: { increment: 3 }
          }
        });
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: { losses: { increment: 1 } }
        });
      } else if (homeScore < awayScore) {
        // 원정팀 승리
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: {
            wins: { increment: 1 },
            points: { increment: 3 }
          }
        });
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: { losses: { increment: 1 } }
        });
      } else {
        // 무승부
        await tx.team.update({
          where: { id: match.homeTeamId },
          data: {
            draws: { increment: 1 },
            points: { increment: 1 }
          }
        });
        await tx.team.update({
          where: { id: match.awayTeamId },
          data: {
            draws: { increment: 1 },
            points: { increment: 1 }
          }
        });
      }
    });
    
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Update result error:', error);
    return NextResponse.json(
      { error: '결과 입력에 실패했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/api/rankings/route.ts

```typescript
import { NextRequest, NextResponse } from 'next/server';
import { prisma } from '@/lib/prisma';

export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const sport = searchParams.get('sport') || '축구';
    const scope = searchParams.get('scope') || 'national';
    const city = searchParams.get('city');
    const district = searchParams.get('district');
    
    let where: any = { sport };
    
    switch(scope) {
      case 'district':
        if (city && district) {
          where.city = city;
          where.district = district;
        }
        break;
      case 'city':
        if (city) {
          where.city = city;
        }
        break;
      case 'national':
      default:
        // sport만 필터링
        break;
    }
    
    const rankings = await prisma.team.findMany({
      where,
      orderBy: [
        { points: 'desc' },
        { wins: 'desc' },
        { draws: 'desc' }
      ],
      include: {
        _count: {
          select: { members: true }
        }
      }
    });
    
    // 순위 추가
    const rankedTeams = rankings.map((team, index) => ({
      ...team,
      rank: index + 1
    }));
    
    return NextResponse.json(rankedTeams);
  } catch (error) {
    console.error('Get rankings error:', error);
    return NextResponse.json(
      { error: '랭킹을 불러오는데 실패했습니다' },
      { status: 500 }
    );
  }
}
```

---

## 📄 app/page.tsx

```tsx
'use client';

import { useState, useEffect } from 'react';

export default function HomePage() {
  const [currentSport, setCurrentSport] = useState('축구');
  const [user, setUser] = useState<any>(null);
  const [myTeams, setMyTeams] = useState([]);
  const [upcomingMatches, setUpcomingMatches] = useState([]);
  const [rankings, setRankings] = useState([]);

  useEffect(() => {
    // 로컬스토리지에서 사용자 정보 가져오기
    const userData = localStorage.getItem('user');
    if (userData) {
      setUser(JSON.parse(userData));
    }
    
    // 데이터 로드
    loadData();
  }, [currentSport]);

  const loadData = async () => {
    // 여기에 API 호출 로직 추가
  };

  return (
    <div className="min-h-screen bg-gray-50">
      {/* 헤더 */}
      <header className="bg-white shadow-sm">
        <div className="max-w-7xl mx-auto px-4 py-4">
          <h1 className="text-2xl font-bold text-gray-900">AllSports</h1>
        </div>
      </header>

      {/* 스포츠 전환 토글 */}
      <div className="flex justify-center p-4 bg-white border-b">
        <div className="flex gap-2">
          <button 
            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
              currentSport === '축구' 
                ? 'bg-blue-500 text-white' 
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
            onClick={() => setCurrentSport('축구')}
          >
            ⚽ 축구
          </button>
          <button 
            className={`px-6 py-2 rounded-lg font-medium transition-colors ${
              currentSport === '풋살' 
                ? 'bg-blue-500 text-white' 
                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
            }`}
            onClick={() => setCurrentSport('풋살')}
          >
            ⚽ 풋살
          </button>
        </div>
      </div>

      <div className="max-w-7xl mx-auto px-4 py-8">
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {/* 내 팀 정보 */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">내 팀</h2>
            {myTeams.length > 0 ? (
              <div className="space-y-3">
                {/* 팀 정보 표시 */}
              </div>
            ) : (
              <p className="text-gray-500">아직 가입한 팀이 없습니다</p>
            )}
          </div>

          {/* 예정된 경기 */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">예정된 경기</h2>
            {upcomingMatches.length > 0 ? (
              <div className="space-y-3">
                {/* 경기 정보 표시 */}
              </div>
            ) : (
              <p className="text-gray-500">예정된 경기가 없습니다</p>
            )}
          </div>

          {/* 지역 랭킹 TOP 5 */}
          <div className="bg-white rounded-lg shadow p-6">
            <h2 className="text-xl font-semibold mb-4">지역 TOP 5</h2>
            {rankings.length > 0 ? (
              <div className="space-y-2">
                {/* 랭킹 표시 */}
              </div>
            ) : (
              <p className="text-gray-500">랭킹 정보가 없습니다</p>
            )}
          </div>
        </div>

        {/* 빠른 메뉴 */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mt-8">
          <a href="/teams" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">👥</div>
            <div className="font-medium">팀 관리</div>
          </a>
          <a href="/matches" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">⚽</div>
            <div className="font-medium">시합 관리</div>
          </a>
          <a href="/rankings" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">🏆</div>
            <div className="font-medium">랭킹</div>
          </a>
          <a href="/profile" className="bg-white rounded-lg shadow p-4 text-center hover:shadow-lg transition-shadow">
            <div className="text-3xl mb-2">👤</div>
            <div className="font-medium">마이페이지</div>
          </a>
        </div>
      </div>
    </div>
  );
}
```

---

## 📄 app/layout.tsx

```tsx
import type { Metadata } from 'next';
import { Inter } from 'next/font/google';
import './globals.css';

const inter = Inter({ subsets: ['latin'] });

export const metadata: Metadata = {
  title: 'AllSports - 아마추어 스포츠 매칭 플랫폼',
  description: '축구와 풋살 팀 매칭 및 랭킹 시스템',
};

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="ko">
      <body className={inter.className}>{children}</body>
    </html>
  );
}
```

---

## 📄 app/globals.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;
```

---

## 📄 tailwind.config.ts

```typescript
import type { Config } from 'tailwindcss';

const config: Config = {
  content: [
    './pages/**/*.{js,ts,jsx,tsx,mdx}',
    './components/**/*.{js,ts,jsx,tsx,mdx}',
    './app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {},
  },
  plugins: [],
};
export default config;
```

---

## 📄 tsconfig.json

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
```

---

## 🚀 실행 방법

1. 위의 모든 파일을 생성한 후:

```bash
# 데이터베이스 마이그레이션
npx prisma generate
npx prisma migrate dev --name init

# 초기 데이터 시딩
npx prisma db seed

# 개발 서버 실행
npm run dev
```

2. 브라우저에서 http://localhost:3000 접속

3. 관리자 로그인:
   - 이메일: admin@allsports.com
   - 비밀번호: admin123

---

## 📝 추가 구현 필요 페이지

- `/login` - 로그인 페이지
- `/register` - 회원가입 페이지
- `/teams` - 팀 목록 페이지
- `/teams/[id]` - 팀 상세 페이지
- `/matches` - 시합 관리 페이지
- `/rankings` - 랭킹 페이지
- `/profile` - 마이페이지
- `/admin` - 관리자 페이지

각 페이지는 위의 API 엔드포인트를 활용하여 구현하시면 됩니다.